import { GleanConfig, GleanOAuthConfig, GleanTokenConfig } from '../config/index.js';
import { Tokens } from './token-store.js';
import { AuthResponse } from './types.js';
/**
 * Validate that the configuration can plausibly access the resource.  This
 * means that either a Glean token was provided, or we have enough information
 * to attempt an OAuth flow.
 *
 * If there's no token, OAuth discovery will occur (i.e. requests to OAuth
 * protected resource metadata and OAuth authorization server metadata).
 *
 * If OAuth is configured but no token is present, then the user will be asked
 * to authenticate via the device authorization flow.
 *
 * If OAuth is configured and tokens are already saved, no authorization flow
 * will be attempted.
 *
 * If an authorization token is expired and a refresh token is available,
 * automatic refresh will be attempted.
 *
 * If this returns true, that means we have an access token, but it doesn't
 * guarantee that the token will validate -- it isn't tested
 *
 * This doesn't guarantee that the token will be accepted -- it isn't tested
 * for things like revocation or server rejection due to unaccepted client,
 * OAuth disabled &c..
 */
export declare function ensureAuthTokenPresence(): Promise<boolean>;
interface SetupMcpRemoteOptions {
    target: 'agents' | 'default';
}
/**
 * Set up mcp-remote.  Copies auth tokens and device flow client information to
 * locations where mcp-remote will read them from.
 *
 * This function must only be called **after** a successful authentication
 * (via, e.g. ensureAuthTokenPresence).
 *
 * Token expiration is set to 1 second to force mcp-remote to fetch a new
 * access token with the refresh token.  Thereafter mcp-remote is taking over
 * the refresh duties until the refresh token expires, at which point users
 * must re-run the configuration.
 */
export declare function setupMcpRemote(opts: SetupMcpRemoteOptions): Promise<void>;
/**
 * Go through the device authorization flow.  It's an error to call this with a
 * Glean token config.  With a basic config, will attempt auth discovery (see
 * `discoverOAuthConfig`).
 *
 * Tokens obtained via authorization will be saved with the token store.
 *
 * Returns the tokens obtained from the authorization flow or `null` if no
 * tokens were obtained (e.g. if the user did not authenticate or did not enter
 * the user code).
 */
export declare function forceAuthorize(config?: GleanConfig): Promise<Tokens | null>;
export declare function attemptUpgradeConfigToOAuth(config: GleanConfig): Promise<GleanTokenConfig | GleanOAuthConfig>;
/**
 * From a basic config, return a `GleanOAuthConfig` if possible.
 *
 * This entails first fetching the OAuth protected resource metadata to obtain:
 *  1. The issuer and
 *  2. The device flow clientId
 *
 * And then fetching the authorization server metadata to obtain:
 *  1. The device authorization endpoint and
 *  2. The token endpoint
 *
 * @returns a complete GleanOAuth config necessary to perform the device
 * authorization flow.
 *
 */
export declare function discoverOAuthConfig(config?: GleanConfig): Promise<GleanOAuthConfig>;
export declare function fetchAuthorizationServerMetadata(issuer: string): Promise<{
    deviceAuthorizationEndpoint: string;
    tokenEndpoint: string;
}>;
interface ProtectedResourceMetadata {
    issuer: string;
    clientId: string;
    clientSecret?: string;
}
export declare function fetchProtectedResourceMetadata(config: GleanConfig): Promise<ProtectedResourceMetadata>;
export declare function forceRefreshTokens(): Promise<void>;
/**
 * Returns the OAuth scopes we need for the issuer.
 *
 * In general this is "openid profile offline_access", but some providers may
 * require different scopes for idiosyncratic reasons.
 *
 * We require two things that are driven by scopes:
 *
 *  - user email (openid profile)
 *  - refresh tokens (offline_access)
 */
export declare function getOAuthScopes(config: GleanOAuthConfig): string;
export declare function fetchDeviceAuthorization(config: GleanOAuthConfig): Promise<AuthResponse>;
export {};
//# sourceMappingURL=auth.d.ts.map