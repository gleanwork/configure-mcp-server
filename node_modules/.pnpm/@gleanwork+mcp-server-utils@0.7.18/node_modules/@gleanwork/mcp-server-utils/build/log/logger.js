import fs from 'fs';
import path from 'path';
import { ensureFileExistsWithLimitedPermissions, getStateDir as getXDGStateDir, } from '../xdg/xdg.js';
export var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 0] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
})(LogLevel || (LogLevel = {}));
/**
 * A simple logger that exposes functions for standard log levels (`trace,
 * `debug`, &c.) for a singleton logger.
 *
 * Logs are written to `$HOME/.local/state/glean/mcp.log` by default (or the
 * XDG equivalent for windows, or if XDG env vars are set).
 *
 * Logs are intended to be provided by users to help with troubleshooting.
 */
export class Logger {
    constructor(appName = 'glean') {
        const logDir = getXDGStateDir(appName);
        // Ensure log directory exists
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
        this.logFilePath = path.join(logDir, 'mcp.log');
        ensureFileExistsWithLimitedPermissions(this.logFilePath);
        this.logLevel = LogLevel.TRACE; // Default to most verbose logging
    }
    static getInstance() {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }
    static reset() {
        Logger.instance = undefined;
    }
    setLogLevel(level) {
        this.logLevel = level;
    }
    log(level, ...args) {
        if (level < this.logLevel)
            return;
        const timestamp = new Date().toISOString();
        const levelName = LogLevel[level];
        let message = '';
        const dataObjects = [];
        // Helper to format errors with causes
        function formatErrorWithCauses(err, indent = 0) {
            const pad = '  '.repeat(indent);
            let out = `${pad}[${err.name}: ${err.message}]`;
            if (err.stack) {
                // Only include stack for the top-level error
                if (indent === 0) {
                    out += `\n${pad}${err.stack.replace(/\n/g, `\n${pad}`)}`;
                }
            }
            // Handle error cause (ES2022 standard, but may be polyfilled)
            const cause = err.cause;
            if (cause instanceof Error) {
                out += `\n${pad}Caused by: ` + formatErrorWithCauses(cause, indent + 1);
            }
            else if (cause !== undefined) {
                out += `\n${pad}Caused by: ${JSON.stringify(cause)}`;
            }
            return out;
        }
        // Process each argument
        args.forEach((arg) => {
            if (typeof arg === 'string') {
                message += (message ? ' ' : '') + arg;
            }
            else if (arg instanceof Error) {
                message += (message ? ' ' : '') + formatErrorWithCauses(arg);
            }
            else if (arg !== null && typeof arg === 'object') {
                dataObjects.push(arg);
            }
            else if (arg !== undefined) {
                // Convert primitives to string
                message += (message ? ' ' : '') + String(arg);
            }
        });
        let logMessage = `[${timestamp}] [${levelName}] ${message}`;
        // Add data objects if any
        if (dataObjects.length > 0) {
            dataObjects.forEach((data) => {
                logMessage += ` ${JSON.stringify(data)}`;
            });
        }
        logMessage += '\n';
        // Append to log file
        fs.appendFileSync(this.logFilePath, logMessage);
    }
    trace(...args) {
        this.log(LogLevel.TRACE, ...args);
    }
    debug(...args) {
        this.log(LogLevel.DEBUG, ...args);
    }
    info(...args) {
        this.log(LogLevel.INFO, ...args);
    }
    warn(...args) {
        this.log(LogLevel.WARN, ...args);
    }
    error(...args) {
        this.log(LogLevel.ERROR, ...args);
    }
}
// Exported functions
export function trace(...args) {
    Logger.getInstance().trace(...args);
}
export function debug(...args) {
    Logger.getInstance().debug(...args);
}
export function info(...args) {
    Logger.getInstance().info(...args);
}
export function warn(...args) {
    Logger.getInstance().warn(...args);
}
export function error(...args) {
    Logger.getInstance().error(...args);
}
//# sourceMappingURL=logger.js.map