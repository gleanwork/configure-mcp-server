import {
  DEBUG,
  OAuthClientInformationFullSchema,
  OAuthTokensSchema,
  checkLockfile,
  createLockfile,
  debugLog,
  deleteConfigFile,
  deleteLockfile,
  getConfigFilePath,
  getServerUrlHash,
  log,
  readJsonFile,
  readTextFile,
  setupOAuthCallbackServerWithLongPoll,
  version,
  writeJsonFile,
  writeTextFile
} from "./chunk-Q334OATA.js";

// src/lib/node-oauth-client-provider.ts
import open from "open";
import { sanitizeUrl } from "strict-url-sanitise";
import { randomUUID } from "node:crypto";
var NodeOAuthClientProvider = class {
  /**
   * Creates a new NodeOAuthClientProvider
   * @param options Configuration options for the provider
   */
  constructor(options) {
    this.options = options;
    this.serverUrlHash = getServerUrlHash(options.serverUrl);
    this.callbackPath = options.callbackPath || "/oauth/callback";
    this.clientName = options.clientName || "MCP CLI Client";
    this.clientUri = options.clientUri || "https://github.com/modelcontextprotocol/mcp-cli";
    this.softwareId = options.softwareId || "2e6dc280-f3c3-4e01-99a7-8181dbd1d23d";
    this.softwareVersion = options.softwareVersion || version;
    this.staticOAuthClientMetadata = options.staticOAuthClientMetadata;
    this.staticOAuthClientInfo = options.staticOAuthClientInfo;
    this._state = randomUUID();
  }
  serverUrlHash;
  callbackPath;
  clientName;
  clientUri;
  softwareId;
  softwareVersion;
  staticOAuthClientMetadata;
  staticOAuthClientInfo;
  _state;
  get redirectUrl() {
    return `http://${this.options.host}:${this.options.callbackPort}${this.callbackPath}`;
  }
  get clientMetadata() {
    return {
      redirect_uris: [this.redirectUrl],
      token_endpoint_auth_method: "none",
      grant_types: ["authorization_code", "refresh_token"],
      response_types: ["code"],
      client_name: this.clientName,
      client_uri: this.clientUri,
      software_id: this.softwareId,
      software_version: this.softwareVersion,
      ...this.staticOAuthClientMetadata
    };
  }
  state() {
    return this._state;
  }
  /**
   * Gets the client information if it exists
   * @returns The client information or undefined
   */
  async clientInformation() {
    if (DEBUG) debugLog("Reading client info");
    if (this.staticOAuthClientInfo) {
      if (DEBUG) debugLog("Returning static client info");
      return this.staticOAuthClientInfo;
    }
    const clientInfo = await readJsonFile(
      this.serverUrlHash,
      "client_info.json",
      OAuthClientInformationFullSchema
    );
    if (DEBUG) debugLog("Client info result:", clientInfo ? "Found" : "Not found");
    return clientInfo;
  }
  /**
   * Saves client information
   * @param clientInformation The client information to save
   */
  async saveClientInformation(clientInformation) {
    if (DEBUG) debugLog("Saving client info", { client_id: clientInformation.client_id });
    await writeJsonFile(this.serverUrlHash, "client_info.json", clientInformation);
  }
  /**
   * Gets the OAuth tokens if they exist
   * @returns The OAuth tokens or undefined
   */
  async tokens() {
    if (DEBUG) {
      debugLog("Reading OAuth tokens");
      debugLog("Token request stack trace:", new Error().stack);
    }
    const tokens = await readJsonFile(this.serverUrlHash, "tokens.json", OAuthTokensSchema);
    if (DEBUG) {
      if (tokens) {
        const timeLeft = tokens.expires_in || 0;
        if (typeof tokens.expires_in !== "number" || tokens.expires_in < 0) {
          debugLog("\u26A0\uFE0F WARNING: Invalid expires_in detected while reading tokens \u26A0\uFE0F", {
            expiresIn: tokens.expires_in,
            tokenObject: JSON.stringify(tokens),
            stack: new Error("Invalid expires_in value").stack
          });
        }
        debugLog("Token result:", {
          found: true,
          hasAccessToken: !!tokens.access_token,
          hasRefreshToken: !!tokens.refresh_token,
          expiresIn: `${timeLeft} seconds`,
          isExpired: timeLeft <= 0,
          expiresInValue: tokens.expires_in
        });
      } else {
        debugLog("Token result: Not found");
      }
    }
    return tokens;
  }
  /**
   * Saves OAuth tokens
   * @param tokens The tokens to save
   */
  async saveTokens(tokens) {
    if (DEBUG) {
      const timeLeft = tokens.expires_in || 0;
      if (typeof tokens.expires_in !== "number" || tokens.expires_in < 0) {
        debugLog("\u26A0\uFE0F WARNING: Invalid expires_in detected in tokens \u26A0\uFE0F", {
          expiresIn: tokens.expires_in,
          tokenObject: JSON.stringify(tokens),
          stack: new Error("Invalid expires_in value").stack
        });
      }
      debugLog("Saving tokens", {
        hasAccessToken: !!tokens.access_token,
        hasRefreshToken: !!tokens.refresh_token,
        expiresIn: `${timeLeft} seconds`,
        expiresInValue: tokens.expires_in
      });
    }
    await writeJsonFile(this.serverUrlHash, "tokens.json", tokens);
  }
  /**
   * Redirects the user to the authorization URL
   * @param authorizationUrl The URL to redirect to
   */
  async redirectToAuthorization(authorizationUrl) {
    log(`
Please authorize this client by visiting:
${authorizationUrl.toString()}
`);
    if (DEBUG) debugLog("Redirecting to authorization URL", authorizationUrl.toString());
    try {
      await open(sanitizeUrl(authorizationUrl.toString()));
      log("Browser opened automatically.");
    } catch (error) {
      log("Could not open browser automatically. Please copy and paste the URL above into your browser.");
      if (DEBUG) debugLog("Failed to open browser", error);
    }
  }
  /**
   * Saves the PKCE code verifier
   * @param codeVerifier The code verifier to save
   */
  async saveCodeVerifier(codeVerifier) {
    if (DEBUG) debugLog("Saving code verifier");
    await writeTextFile(this.serverUrlHash, "code_verifier.txt", codeVerifier);
  }
  /**
   * Gets the PKCE code verifier
   * @returns The code verifier
   */
  async codeVerifier() {
    if (DEBUG) debugLog("Reading code verifier");
    const verifier = await readTextFile(this.serverUrlHash, "code_verifier.txt", "No code verifier saved for session");
    if (DEBUG) debugLog("Code verifier found:", !!verifier);
    return verifier;
  }
  /**
   * Invalidates the specified credentials
   * @param scope The scope of credentials to invalidate
   */
  async invalidateCredentials(scope) {
    if (DEBUG) debugLog(`Invalidating credentials: ${scope}`);
    switch (scope) {
      case "all":
        await Promise.all([
          deleteConfigFile(this.serverUrlHash, "client_info.json"),
          deleteConfigFile(this.serverUrlHash, "tokens.json"),
          deleteConfigFile(this.serverUrlHash, "code_verifier.txt")
        ]);
        if (DEBUG) debugLog("All credentials invalidated");
        break;
      case "client":
        await deleteConfigFile(this.serverUrlHash, "client_info.json");
        if (DEBUG) debugLog("Client information invalidated");
        break;
      case "tokens":
        await deleteConfigFile(this.serverUrlHash, "tokens.json");
        if (DEBUG) debugLog("OAuth tokens invalidated");
        break;
      case "verifier":
        await deleteConfigFile(this.serverUrlHash, "code_verifier.txt");
        if (DEBUG) debugLog("Code verifier invalidated");
        break;
      default:
        throw new Error(`Unknown credential scope: ${scope}`);
    }
  }
};

// src/lib/coordination.ts
import express from "express";
import { unlinkSync } from "fs";
async function isPidRunning(pid) {
  try {
    process.kill(pid, 0);
    if (DEBUG) debugLog(`Process ${pid} is running`);
    return true;
  } catch (err) {
    if (DEBUG) debugLog(`Process ${pid} is not running`, err);
    return false;
  }
}
async function isLockValid(lockData) {
  if (DEBUG) debugLog("Checking if lockfile is valid", lockData);
  const MAX_LOCK_AGE = 30 * 60 * 1e3;
  if (Date.now() - lockData.timestamp > MAX_LOCK_AGE) {
    log("Lockfile is too old");
    if (DEBUG)
      debugLog("Lockfile is too old", {
        age: Date.now() - lockData.timestamp,
        maxAge: MAX_LOCK_AGE
      });
    return false;
  }
  if (!await isPidRunning(lockData.pid)) {
    log("Process from lockfile is not running");
    if (DEBUG) debugLog("Process from lockfile is not running", { pid: lockData.pid });
    return false;
  }
  try {
    if (DEBUG) debugLog("Checking if endpoint is accessible", { port: lockData.port });
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 1e3);
    const response = await fetch(`http://127.0.0.1:${lockData.port}/wait-for-auth?poll=false`, {
      signal: controller.signal
    });
    clearTimeout(timeout);
    const isValid = response.status === 200 || response.status === 202;
    if (DEBUG) debugLog(`Endpoint check result: ${isValid ? "valid" : "invalid"}`, { status: response.status });
    return isValid;
  } catch (error) {
    log(`Error connecting to auth server: ${error.message}`);
    if (DEBUG) debugLog("Error connecting to auth server", error);
    return false;
  }
}
async function waitForAuthentication(port) {
  log(`Waiting for authentication from the server on port ${port}...`);
  try {
    let attempts = 0;
    while (true) {
      attempts++;
      const url = `http://127.0.0.1:${port}/wait-for-auth`;
      log(`Querying: ${url}`);
      if (DEBUG) debugLog(`Poll attempt ${attempts}`);
      try {
        const response = await fetch(url);
        if (DEBUG) debugLog(`Poll response status: ${response.status}`);
        if (response.status === 200) {
          log(`Authentication completed by other instance`);
          return true;
        } else if (response.status === 202) {
          log(`Authentication still in progress`);
          if (DEBUG) debugLog(`Will retry in 1s`);
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        } else {
          log(`Unexpected response status: ${response.status}`);
          return false;
        }
      } catch (fetchError) {
        if (DEBUG) debugLog(`Fetch error during poll`, fetchError);
        await new Promise((resolve) => setTimeout(resolve, 2e3));
      }
    }
  } catch (error) {
    log(`Error waiting for authentication: ${error.message}`);
    if (DEBUG) debugLog(`Error waiting for authentication`, error);
    return false;
  }
}
function createLazyAuthCoordinator(serverUrlHash, callbackPort, events) {
  let authState = null;
  return {
    initializeAuth: async () => {
      if (authState) {
        if (DEBUG) debugLog("Auth already initialized, reusing existing state");
        return authState;
      }
      log("Initializing auth coordination on-demand");
      if (DEBUG) debugLog("Initializing auth coordination on-demand", { serverUrlHash, callbackPort });
      authState = await coordinateAuth(serverUrlHash, callbackPort, events);
      if (DEBUG) debugLog("Auth coordination completed", { skipBrowserAuth: authState.skipBrowserAuth });
      return authState;
    }
  };
}
async function coordinateAuth(serverUrlHash, callbackPort, events) {
  if (DEBUG) debugLog("Coordinating authentication", { serverUrlHash, callbackPort });
  const lockData = process.platform === "win32" ? null : await checkLockfile(serverUrlHash);
  if (DEBUG) {
    if (process.platform === "win32") {
      debugLog("Skipping lockfile check on Windows");
    } else {
      debugLog("Lockfile check result", { found: !!lockData, lockData });
    }
  }
  if (lockData && await isLockValid(lockData)) {
    log(`Another instance is handling authentication on port ${lockData.port} (pid: ${lockData.pid})`);
    try {
      if (DEBUG) debugLog("Waiting for authentication from other instance");
      const authCompleted = await waitForAuthentication(lockData.port);
      if (authCompleted) {
        log("Authentication completed by another instance. Using tokens from disk");
        const dummyServer = express().listen(0);
        const dummyPort = dummyServer.address().port;
        if (DEBUG) debugLog("Started dummy server", { port: dummyPort });
        const dummyWaitForAuthCode = () => {
          log("WARNING: waitForAuthCode called in secondary instance - this is unexpected");
          return new Promise(() => {
          });
        };
        return {
          server: dummyServer,
          waitForAuthCode: dummyWaitForAuthCode,
          skipBrowserAuth: true
        };
      } else {
        log("Taking over authentication process...");
      }
    } catch (error) {
      log(`Error waiting for authentication: ${error}`);
      if (DEBUG) debugLog("Error waiting for authentication", error);
    }
    if (DEBUG) debugLog("Other instance did not complete auth successfully, deleting lockfile");
    await deleteLockfile(serverUrlHash);
  } else if (lockData) {
    log("Found invalid lockfile, deleting it");
    await deleteLockfile(serverUrlHash);
  }
  if (DEBUG) debugLog("Setting up OAuth callback server", { port: callbackPort });
  const { server, waitForAuthCode, authCompletedPromise } = setupOAuthCallbackServerWithLongPoll({
    port: callbackPort,
    path: "/oauth/callback",
    events
  });
  const address = server.address();
  const actualPort = address.port;
  if (DEBUG) debugLog("OAuth callback server running", { port: actualPort });
  log(`Creating lockfile for server ${serverUrlHash} with process ${process.pid} on port ${actualPort}`);
  await createLockfile(serverUrlHash, process.pid, actualPort);
  const cleanupHandler = async () => {
    try {
      log(`Cleaning up lockfile for server ${serverUrlHash}`);
      await deleteLockfile(serverUrlHash);
    } catch (error) {
      log(`Error cleaning up lockfile: ${error}`);
      if (DEBUG) debugLog("Error cleaning up lockfile", error);
    }
  };
  process.once("exit", () => {
    try {
      const configPath = getConfigFilePath(serverUrlHash, "lock.json");
      unlinkSync(configPath);
      if (DEBUG) console.error(`[DEBUG] Removed lockfile on exit: ${configPath}`);
    } catch (error) {
      if (DEBUG) console.error(`[DEBUG] Error removing lockfile on exit:`, error);
    }
  });
  process.once("SIGINT", async () => {
    if (DEBUG) debugLog("Received SIGINT signal, cleaning up");
    await cleanupHandler();
  });
  if (DEBUG) debugLog("Auth coordination complete, returning primary instance handlers");
  return {
    server,
    waitForAuthCode,
    skipBrowserAuth: false
  };
}

export {
  NodeOAuthClientProvider,
  createLazyAuthCoordinator
};
