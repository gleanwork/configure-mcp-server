// src/schemas.ts
import { z } from "zod";
var PlatformSchema = z.enum(["darwin", "linux", "win32"]);
var ClientIdSchema = z.enum([
  "claude-code",
  "vscode",
  "claude-desktop",
  "claude-teams-enterprise",
  "cursor",
  "goose",
  "windsurf",
  "chatgpt"
]);
var ClientConnectionSupportSchema = z.enum(["http", "stdio-only", "both"]);
var ServerTypeSchema = z.enum(["http", "stdio"]);
var LocalConfigSupportSchema = z.enum(["full", "none"]);
var ServerModeSchema = z.enum(["local", "remote"]);
var HttpConfigStructureSchema = z.object({
  typeField: z.string().optional(),
  urlField: z.string()
});
var StdioConfigStructureSchema = z.object({
  typeField: z.string().optional(),
  commandField: z.string(),
  argsField: z.string(),
  envField: z.string().optional()
});
var ConfigStructureSchema = z.object({
  serverKey: z.string(),
  httpConfig: HttpConfigStructureSchema.optional(),
  stdioConfig: StdioConfigStructureSchema.optional()
});
var PlatformPathsSchema = z.object({
  darwin: z.string().optional(),
  linux: z.string().optional(),
  win32: z.string().optional()
});
var MCPClientConfigSchema = z.object({
  id: ClientIdSchema,
  name: z.string(),
  displayName: z.string(),
  description: z.string(),
  localConfigSupport: LocalConfigSupportSchema,
  localConfigNotes: z.string().optional(),
  documentationUrl: z.string().url().optional(),
  clientSupports: ClientConnectionSupportSchema,
  requiresMcpRemoteForHttp: z.boolean(),
  supportedPlatforms: z.array(PlatformSchema),
  configFormat: z.enum(["json", "yaml"]),
  configPath: PlatformPathsSchema,
  oneClick: z.object({
    protocol: z.string(),
    urlTemplate: z.string(),
    configFormat: z.enum(["base64-json", "url-encoded-json"])
  }).optional(),
  configStructure: ConfigStructureSchema,
  securityNotes: z.string().optional()
});
var BuildOptionsSchema = z.object({
  includeWrapper: z.boolean().optional()
});
var GleanServerConfigSchema = z.object({
  mode: ServerModeSchema,
  serverUrl: z.string().url().optional(),
  serverName: z.string().optional(),
  instance: z.string().optional(),
  apiToken: z.string().optional()
}).merge(BuildOptionsSchema);
function validateClientConfig(data) {
  return MCPClientConfigSchema.parse(data);
}
function validateServerConfig(data) {
  return GleanServerConfigSchema.parse(data);
}
function safeValidateClientConfig(data) {
  return MCPClientConfigSchema.safeParse(data);
}
function safeValidateServerConfig(data) {
  return GleanServerConfigSchema.safeParse(data);
}
var HttpServerConfigSchema = z.object({
  type: z.literal("http"),
  url: z.string().url()
});
var StdioServerConfigSchema = z.object({
  type: z.literal("stdio").optional(),
  // Some clients don't include type field
  command: z.string(),
  args: z.array(z.string()),
  env: z.record(z.string(), z.string()).optional()
});
var StdioServerConfigAltSchema = z.object({
  type: z.literal("stdio").optional(),
  cmd: z.string(),
  // Goose uses 'cmd' instead of 'command'
  args: z.array(z.string()),
  env: z.record(z.string(), z.string()).optional()
});
var ServerConfigSchema = z.union([
  HttpServerConfigSchema,
  StdioServerConfigSchema,
  StdioServerConfigAltSchema
]);
var McpServersConfigSchema = z.object({
  mcpServers: z.record(z.string(), ServerConfigSchema)
});
var VsCodeConfigSchema = z.object({
  servers: z.record(z.string(), ServerConfigSchema)
});
var GooseServerConfigSchema = z.object({
  name: z.string(),
  cmd: z.string(),
  args: z.array(z.union([z.string(), z.number()])),
  type: z.literal("stdio"),
  timeout: z.number(),
  enabled: z.boolean(),
  bundled: z.null(),
  description: z.null(),
  env_keys: z.array(z.string()),
  envs: z.record(z.string(), z.string())
});
var GooseConfigSchema = z.object({
  extensions: z.record(z.string(), GooseServerConfigSchema)
});
function validateGeneratedConfig(config, clientId) {
  let schema;
  switch (clientId) {
    case "vscode":
      schema = VsCodeConfigSchema;
      break;
    case "goose":
      schema = GooseConfigSchema;
      break;
    case "claude-code":
    case "claude-desktop":
    case "cursor":
    case "windsurf":
      schema = McpServersConfigSchema;
      break;
    default:
      return {
        success: false,
        error: new z.ZodError([
          {
            code: "custom",
            message: `Unknown client ID: ${clientId}`,
            path: []
          }
        ])
      };
  }
  const result = schema.safeParse(config);
  if (result.success) {
    return { success: true, data: result.data };
  } else {
    return { success: false, error: result.error };
  }
}
var validateMcpServersConfig = McpServersConfigSchema.parse;
var validateVsCodeConfig = VsCodeConfigSchema.parse;
var validateGooseConfig = GooseConfigSchema.parse;
var safeValidateMcpServersConfig = McpServersConfigSchema.safeParse;
var safeValidateVsCodeConfig = VsCodeConfigSchema.safeParse;
var safeValidateGooseConfig = GooseConfigSchema.safeParse;

// src/constants.ts
var CLIENT = {
  CLAUDE_CODE: "claude-code",
  CLAUDE_DESKTOP: "claude-desktop",
  CLAUDE_TEAMS_ENTERPRISE: "claude-teams-enterprise",
  CURSOR: "cursor",
  VSCODE: "vscode",
  WINDSURF: "windsurf",
  GOOSE: "goose",
  CHATGPT: "chatgpt"
};
var CLIENT_DISPLAY_NAME = {
  CLAUDE_CODE: "Claude Code",
  CLAUDE_DESKTOP: "Claude for Desktop",
  CLAUDE_TEAMS_ENTERPRISE: "Claude for Teams/Enterprise",
  CURSOR: "Cursor",
  VSCODE: "VS Code",
  WINDSURF: "Windsurf",
  GOOSE: "Goose",
  CHATGPT: "ChatGPT"
};
function getDisplayName(clientId) {
  const mapping = {
    [CLIENT.CLAUDE_CODE]: CLIENT_DISPLAY_NAME.CLAUDE_CODE,
    [CLIENT.CLAUDE_DESKTOP]: CLIENT_DISPLAY_NAME.CLAUDE_DESKTOP,
    [CLIENT.CLAUDE_TEAMS_ENTERPRISE]: CLIENT_DISPLAY_NAME.CLAUDE_TEAMS_ENTERPRISE,
    [CLIENT.CURSOR]: CLIENT_DISPLAY_NAME.CURSOR,
    [CLIENT.VSCODE]: CLIENT_DISPLAY_NAME.VSCODE,
    [CLIENT.WINDSURF]: CLIENT_DISPLAY_NAME.WINDSURF,
    [CLIENT.GOOSE]: CLIENT_DISPLAY_NAME.GOOSE,
    [CLIENT.CHATGPT]: CLIENT_DISPLAY_NAME.CHATGPT
  };
  return mapping[clientId];
}

// src/server-name.ts
function extractServerNameFromUrl(url) {
  const match = url.match(/\/mcp\/([^/]+)(?:\/|$)/);
  return match ? match[1] : null;
}
function buildMcpServerName(options) {
  if (options.serverName) {
    if (options.serverName === "glean" || options.serverName.startsWith("glean_")) {
      return options.serverName;
    }
    return `glean_${options.serverName}`;
  }
  if (options.mode === "local") {
    return "glean_local";
  }
  if (options.agents) {
    return "glean_agents";
  }
  if (options.mode === "remote" && options.serverUrl) {
    const extracted = extractServerNameFromUrl(options.serverUrl);
    if (extracted) {
      return `glean_${extracted}`;
    }
  }
  return "glean";
}
function normalizeServerName(name) {
  const withoutPrefix = name.replace(/^glean_?/i, "");
  if (!withoutPrefix) {
    return "glean";
  }
  return `glean_${withoutPrefix.toLowerCase()}`;
}

// src/builder.ts
import * as yaml from "js-yaml";
function isNodeEnvironment() {
  return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
}
var ConfigBuilder = class {
  constructor(config) {
    this.config = config;
    this.platform = this.detectPlatform();
  }
  platform;
  detectPlatform() {
    if (isNodeEnvironment()) {
      try {
        return process.platform;
      } catch {
      }
    }
    if (typeof globalThis !== "undefined" && "navigator" in globalThis) {
      const nav = globalThis.navigator;
      if (nav && nav.userAgent) {
        const ua = nav.userAgent.toLowerCase();
        if (ua.includes("mac")) return "darwin";
        if (ua.includes("win")) return "win32";
        return "linux";
      }
    }
    return "darwin";
  }
  buildConfiguration(gleanConfig) {
    if (this.config.localConfigSupport === "none") {
      throw new Error(
        `${this.config.displayName} does not support local configuration. ${this.config.localConfigNotes || "Configuration must be done through other means."}`
      );
    }
    const validatedConfig = validateServerConfig(gleanConfig);
    const includeWrapper = validatedConfig.includeWrapper !== false;
    let configObj = {};
    if (validatedConfig.mode === "local") {
      configObj = this.buildLocalConfig(validatedConfig, includeWrapper);
    } else if (validatedConfig.mode === "remote") {
      configObj = this.buildRemoteConfig(validatedConfig, includeWrapper);
    } else {
      throw new Error(`Invalid server mode: ${validatedConfig.mode}`);
    }
    if (this.config.configFormat === "json") {
      return JSON.stringify(configObj, null, 2);
    } else if (this.config.configFormat === "yaml") {
      return yaml.dump(configObj);
    }
    throw new Error(`Unsupported config format: ${this.config.configFormat}`);
  }
  buildLocalConfig(gleanConfig, includeWrapper = true) {
    const { serverKey, stdioConfig } = this.config.configStructure;
    if (!stdioConfig) {
      throw new Error(`Client ${this.config.id} doesn't support local server configuration`);
    }
    const serverName = buildMcpServerName({
      mode: "local",
      serverName: gleanConfig.serverName
    });
    const serverConfig = {};
    serverConfig[stdioConfig.commandField] = "npx";
    serverConfig[stdioConfig.argsField] = ["-y", "@gleanwork/local-mcp-server"];
    if (stdioConfig.typeField) {
      serverConfig[stdioConfig.typeField] = "stdio";
    }
    if (stdioConfig.envField) {
      const env = {};
      if (gleanConfig.instance) {
        if (gleanConfig.instance.startsWith("http://") || gleanConfig.instance.startsWith("https://")) {
          env.GLEAN_URL = gleanConfig.instance;
        } else {
          env.GLEAN_INSTANCE = gleanConfig.instance;
        }
      }
      if (gleanConfig.apiToken) {
        env.GLEAN_API_TOKEN = gleanConfig.apiToken;
      }
      if (Object.keys(env).length > 0) {
        serverConfig[stdioConfig.envField] = env;
      }
    }
    if (this.config.id === "goose") {
      const envs = {};
      if (gleanConfig.instance) {
        if (gleanConfig.instance.startsWith("http://") || gleanConfig.instance.startsWith("https://")) {
          envs.GLEAN_URL = gleanConfig.instance;
        } else {
          envs.GLEAN_INSTANCE = gleanConfig.instance;
        }
      }
      if (gleanConfig.apiToken) {
        envs.GLEAN_API_TOKEN = gleanConfig.apiToken;
      }
      const gooseServerConfig = {
        name: serverName,
        ...serverConfig,
        type: "stdio",
        timeout: 300,
        enabled: true,
        bundled: null,
        description: null,
        env_keys: [],
        envs
      };
      if (!includeWrapper) {
        return {
          [serverName]: gooseServerConfig
        };
      }
      return {
        extensions: {
          [serverName]: gooseServerConfig
        }
      };
    }
    if (!includeWrapper) {
      return {
        [serverName]: serverConfig
      };
    }
    return {
      [serverKey]: {
        [serverName]: serverConfig
      }
    };
  }
  buildRemoteConfig(gleanConfig, includeWrapper = true) {
    if (!gleanConfig.serverUrl) {
      throw new Error("Remote configuration requires serverUrl");
    }
    const { serverKey, httpConfig, stdioConfig } = this.config.configStructure;
    const serverName = buildMcpServerName({
      mode: "remote",
      serverUrl: gleanConfig.serverUrl,
      serverName: gleanConfig.serverName
    });
    if (httpConfig && (this.config.clientSupports === "http" || this.config.clientSupports === "both")) {
      const serverConfig = {};
      if (httpConfig.typeField) {
        serverConfig[httpConfig.typeField] = "http";
      }
      serverConfig[httpConfig.urlField] = gleanConfig.serverUrl;
      if (!includeWrapper) {
        return {
          [serverName]: serverConfig
        };
      }
      return {
        [serverKey]: {
          [serverName]: serverConfig
        }
      };
    } else if (stdioConfig) {
      const serverConfig = {};
      if (stdioConfig.typeField) {
        serverConfig[stdioConfig.typeField] = "stdio";
      }
      serverConfig[stdioConfig.commandField] = "npx";
      serverConfig[stdioConfig.argsField] = ["-y", "mcp-remote", gleanConfig.serverUrl];
      if (this.config.id === "goose") {
        const gooseServerConfig = {
          name: serverName,
          ...serverConfig,
          type: "stdio",
          timeout: 300,
          enabled: true,
          bundled: null,
          description: null,
          env_keys: [],
          envs: {}
        };
        if (!includeWrapper) {
          return {
            [serverName]: gooseServerConfig
          };
        }
        return {
          extensions: {
            [serverName]: gooseServerConfig
          }
        };
      }
      if (!includeWrapper) {
        return {
          [serverName]: serverConfig
        };
      }
      return {
        [serverKey]: {
          [serverName]: serverConfig
        }
      };
    } else {
      throw new Error(`Client ${this.config.id} doesn't support remote server configuration`);
    }
  }
  buildOneClickUrl(gleanConfig) {
    if (!this.config.oneClick) {
      throw new Error(`${this.config.displayName} does not support one-click installation`);
    }
    const serverName = buildMcpServerName({
      mode: gleanConfig.mode,
      serverUrl: gleanConfig.serverUrl,
      serverName: gleanConfig.serverName
    });
    let configObj;
    if (this.config.clientSupports === "stdio-only" && gleanConfig.mode === "remote") {
      configObj = {
        command: "npx",
        args: ["-y", "mcp-remote", gleanConfig.serverUrl]
      };
    } else if (this.config.clientSupports === "http" && gleanConfig.mode === "remote") {
      configObj = {
        url: gleanConfig.serverUrl
      };
    } else if (gleanConfig.mode === "local") {
      configObj = {
        command: "npx",
        args: ["-y", "@gleanwork/local-mcp-server"]
      };
    } else {
      configObj = {
        command: "npx",
        args: ["-y", "mcp-remote", gleanConfig.serverUrl]
      };
    }
    let encodedConfig;
    if (this.config.oneClick.configFormat === "base64-json") {
      encodedConfig = Buffer.from(JSON.stringify(configObj)).toString("base64");
    } else if (this.config.oneClick.configFormat === "url-encoded-json") {
      encodedConfig = encodeURIComponent(JSON.stringify(configObj));
    } else {
      throw new Error(`Unknown one-click config format: ${this.config.oneClick.configFormat}`);
    }
    return this.config.oneClick.urlTemplate.replace("{{name}}", encodeURIComponent(serverName)).replace("{{config}}", encodedConfig);
  }
  getConfigPath() {
    if (!isNodeEnvironment()) {
      throw new Error("getConfigPath() is only available in Node.js environment");
    }
    if (this.config.localConfigSupport === "none") {
      throw new Error(
        `${this.config.displayName} does not support local configuration. ${this.config.localConfigNotes || "Configuration must be done through other means."}`
      );
    }
    const platformPath = this.config.configPath[this.platform];
    if (!platformPath) {
      throw new Error(`Platform ${this.platform} not supported for ${this.config.displayName}`);
    }
    return this.expandPath(platformPath);
  }
  expandPath(filepath) {
    const homedir = process.env.HOME || process.env.USERPROFILE || "";
    const sep = process.platform === "win32" ? "\\" : "/";
    filepath = filepath.replace(/\$HOME/g, homedir);
    if (filepath.startsWith("~")) {
      filepath = homedir + (filepath.startsWith("~/") || filepath.startsWith("~\\") ? "" : sep) + filepath.slice(1);
    }
    filepath = filepath.replace(/%([^%]+)%/g, (_, envVar) => {
      return process.env[envVar] || "";
    });
    return filepath;
  }
  async writeConfiguration(gleanConfig) {
    if (!isNodeEnvironment()) {
      throw new Error("writeConfiguration() is only available in Node.js environment");
    }
    if (this.config.localConfigSupport === "none") {
      throw new Error(
        `${this.config.displayName} does not support local configuration. ${this.config.localConfigNotes || "Configuration must be done through other means."}`
      );
    }
    const content = this.buildConfiguration(gleanConfig);
    const configPath = this.getConfigPath();
    const fs = await import("fs");
    const path = await import("path");
    const { mkdirp } = await import("mkdirp");
    const chalk = await import("chalk");
    await mkdirp(path.dirname(configPath));
    if (fs.existsSync(configPath)) {
      const backupPath = `${configPath}.backup.${Date.now()}`;
      fs.copyFileSync(configPath, backupPath);
      console.log(chalk.default.yellow(`\u{1F4C1} Backed up existing config to: ${backupPath}`));
    }
    fs.writeFileSync(configPath, content, "utf-8");
    console.log(chalk.default.green(`\u2705 Configuration written to: ${configPath}`));
    if (this.config.requiresMcpRemoteForHttp && gleanConfig.mode === "remote") {
      console.log(
        chalk.default.blue("\n\u2139\uFE0F  This client uses mcp-remote to connect to HTTP servers.")
      );
      console.log(chalk.default.blue("   Make sure mcp-remote is available via npx."));
    }
  }
};

// configs/chatgpt.json
var chatgpt_default = {
  id: "chatgpt",
  name: "chatgpt",
  displayName: "ChatGPT",
  description: "ChatGPT web interface - requires GPT configuration through web UI",
  localConfigSupport: "none",
  localConfigNotes: "ChatGPT is web-based and requires creating custom GPTs through their web UI. No local configuration file support.",
  clientSupports: "stdio-only",
  requiresMcpRemoteForHttp: true,
  supportedPlatforms: [],
  configFormat: "json",
  configPath: {},
  documentationUrl: "https://platform.openai.com/docs",
  configStructure: {
    serverKey: ""
  }
};

// configs/claude-code.json
var claude_code_default = {
  id: "claude-code",
  name: "claude-code",
  displayName: "Claude Code",
  description: "Claude Code with native HTTP support",
  localConfigSupport: "full",
  documentationUrl: "https://docs.anthropic.com/en/docs/claude-code",
  clientSupports: "http",
  requiresMcpRemoteForHttp: false,
  supportedPlatforms: ["darwin", "linux", "win32"],
  configFormat: "json",
  configPath: {
    darwin: "$HOME/.claude.json",
    linux: "$HOME/.claude.json",
    win32: "%USERPROFILE%\\.claude.json"
  },
  configStructure: {
    serverKey: "mcpServers",
    httpConfig: {
      typeField: "type",
      urlField: "url"
    },
    stdioConfig: {
      typeField: "type",
      commandField: "command",
      argsField: "args",
      envField: "env"
    }
  }
};

// configs/claude-desktop.json
var claude_desktop_default = {
  id: "claude-desktop",
  name: "claude-desktop",
  displayName: "Claude for Desktop",
  description: "Claude Desktop only supports stdio, requires mcp-remote for HTTP servers",
  localConfigSupport: "full",
  localConfigNotes: "Requires mcp-remote for remote servers",
  documentationUrl: "https://docs.anthropic.com/en/docs/claude-desktop",
  clientSupports: "stdio-only",
  requiresMcpRemoteForHttp: true,
  supportedPlatforms: ["darwin", "win32", "linux"],
  configFormat: "json",
  configPath: {
    darwin: "$HOME/Library/Application Support/Claude/claude_desktop_config.json",
    win32: "%APPDATA%\\Claude\\claude_desktop_config.json",
    linux: "$HOME/.config/Claude/claude_desktop_config.json"
  },
  configStructure: {
    serverKey: "mcpServers",
    stdioConfig: {
      typeField: "type",
      commandField: "command",
      argsField: "args",
      envField: "env"
    }
  }
};

// configs/claude-teams-enterprise.json
var claude_teams_enterprise_default = {
  id: "claude-teams-enterprise",
  name: "claude-teams-enterprise",
  displayName: "Claude for Teams/Enterprise",
  description: "Claude for Teams and Enterprise",
  localConfigSupport: "none",
  localConfigNotes: "MCP servers are centrally managed by admins. No local configuration support - servers must be configured at the organization level.",
  clientSupports: "stdio-only",
  requiresMcpRemoteForHttp: true,
  supportedPlatforms: [],
  configFormat: "json",
  configPath: {},
  documentationUrl: "https://docs.anthropic.com/en/docs/claude-desktop",
  configStructure: {
    serverKey: ""
  }
};

// configs/cursor.json
var cursor_default = {
  id: "cursor",
  name: "cursor",
  displayName: "Cursor",
  description: "Cursor with native HTTP support",
  localConfigSupport: "full",
  documentationUrl: "https://docs.cursor.com/context/model-context-protocol",
  clientSupports: "http",
  requiresMcpRemoteForHttp: false,
  supportedPlatforms: ["darwin", "linux", "win32"],
  configFormat: "json",
  configPath: {
    darwin: "$HOME/.cursor/mcp.json",
    linux: "$HOME/.cursor/mcp.json",
    win32: "%USERPROFILE%\\.cursor\\mcp.json"
  },
  oneClick: {
    protocol: "cursor://",
    urlTemplate: "cursor://anysphere.cursor-deeplink/mcp/install?name={{name}}&config={{config}}",
    configFormat: "base64-json"
  },
  configStructure: {
    serverKey: "mcpServers",
    httpConfig: {
      typeField: "type",
      urlField: "url"
    },
    stdioConfig: {
      typeField: "type",
      commandField: "command",
      argsField: "args",
      envField: "env"
    }
  }
};

// configs/goose.json
var goose_default = {
  id: "goose",
  name: "goose",
  displayName: "Goose",
  description: "Goose only supports stdio, requires mcp-remote for HTTP servers",
  localConfigSupport: "full",
  localConfigNotes: "Requires mcp-remote for remote servers",
  documentationUrl: "https://github.com/square/goose",
  clientSupports: "stdio-only",
  requiresMcpRemoteForHttp: true,
  supportedPlatforms: ["darwin", "linux", "win32"],
  configFormat: "yaml",
  configPath: {
    darwin: "$HOME/.config/goose/config.yaml",
    linux: "$HOME/.config/goose/config.yaml",
    win32: "%USERPROFILE%\\.config\\goose\\config.yaml"
  },
  configStructure: {
    serverKey: "extensions",
    stdioConfig: {
      commandField: "cmd",
      argsField: "args"
    }
  }
};

// configs/vscode.json
var vscode_default = {
  id: "vscode",
  name: "vscode",
  displayName: "Visual Studio Code",
  description: "VS Code with native HTTP support",
  localConfigSupport: "full",
  documentationUrl: "https://code.visualstudio.com/docs",
  clientSupports: "http",
  requiresMcpRemoteForHttp: false,
  supportedPlatforms: ["darwin", "linux", "win32"],
  configFormat: "json",
  configPath: {
    darwin: "$HOME/Library/Application Support/Code/User/mcp.json",
    linux: "$HOME/.config/Code/User/mcp.json",
    win32: "%APPDATA%\\Code\\User\\mcp.json"
  },
  configStructure: {
    serverKey: "servers",
    httpConfig: {
      typeField: "type",
      urlField: "url"
    },
    stdioConfig: {
      typeField: "type",
      commandField: "command",
      argsField: "args",
      envField: "env"
    }
  }
};

// configs/windsurf.json
var windsurf_default = {
  id: "windsurf",
  name: "windsurf",
  displayName: "Windsurf",
  description: "Windsurf only supports stdio, requires mcp-remote for HTTP servers",
  localConfigSupport: "full",
  localConfigNotes: "Requires mcp-remote for remote servers",
  documentationUrl: "https://docs.codeium.com/windsurf",
  clientSupports: "stdio-only",
  requiresMcpRemoteForHttp: true,
  supportedPlatforms: ["darwin", "linux", "win32"],
  configFormat: "json",
  configPath: {
    darwin: "$HOME/.codeium/windsurf/mcp_config.json",
    linux: "$HOME/.codeium/windsurf/mcp_config.json",
    win32: "%USERPROFILE%\\.codeium\\windsurf\\mcp_config.json"
  },
  configStructure: {
    serverKey: "mcpServers",
    stdioConfig: {
      commandField: "command",
      argsField: "args",
      envField: "env"
    }
  }
};

// src/registry.ts
var allConfigs = [
  chatgpt_default,
  claude_code_default,
  claude_desktop_default,
  claude_teams_enterprise_default,
  cursor_default,
  goose_default,
  vscode_default,
  windsurf_default
];
var MCPConfigRegistry = class {
  configs = /* @__PURE__ */ new Map();
  constructor() {
    this.loadConfigs();
  }
  loadConfigs() {
    for (const data of allConfigs) {
      try {
        const result = safeValidateClientConfig(data);
        if (!result.success) {
          const errorMessage = result.error.issues.map((err) => `  - ${err.path.join(".")}: ${err.message}`).join("\n");
          throw new Error(`Validation failed:
${errorMessage}`);
        }
        const config = result.data;
        this.validateBusinessRules(config);
        this.configs.set(config.id, config);
      } catch (error) {
        const configId = data.id || "unknown";
        if (error instanceof Error) {
          console.error(`Failed to load config ${configId}:
${error.message}`);
        } else {
          console.error(`Failed to load config ${configId}:`, error);
        }
      }
    }
  }
  validateBusinessRules(config) {
    if (config.localConfigSupport === "none") {
      return;
    }
    if (config.clientSupports === "stdio-only" && !config.requiresMcpRemoteForHttp) {
      throw new Error(`stdio-only clients must require mcp-remote for HTTP servers`);
    }
    if (config.clientSupports === "http" && config.requiresMcpRemoteForHttp) {
      throw new Error(`HTTP-supporting clients shouldn't require mcp-remote`);
    }
    if (!config.configStructure.httpConfig && !config.configStructure.stdioConfig) {
      throw new Error(`Client must support at least one configuration type (http or stdio)`);
    }
    if ((config.clientSupports === "http" || config.clientSupports === "both") && !config.configStructure.httpConfig) {
      throw new Error(`Client with HTTP support must have httpConfig defined`);
    }
  }
  getConfig(clientId) {
    return this.configs.get(clientId);
  }
  getAllConfigs() {
    return Array.from(this.configs.values());
  }
  getNativeHttpClients() {
    return this.getAllConfigs().filter(
      (config) => config.clientSupports === "http" || config.clientSupports === "both"
    );
  }
  getBridgeRequiredClients() {
    return this.getAllConfigs().filter((config) => config.requiresMcpRemoteForHttp === true);
  }
  getStdioOnlyClients() {
    return this.getAllConfigs().filter((config) => config.clientSupports === "stdio-only");
  }
  getClientsWithOneClick() {
    return this.getAllConfigs().filter((config) => config.oneClick !== void 0);
  }
  getSupportedClients() {
    return this.getAllConfigs().filter((config) => config.localConfigSupport === "full");
  }
  getClientsByPlatform(platform) {
    return this.getAllConfigs().filter((config) => config.supportedPlatforms.includes(platform));
  }
  getUnsupportedClients() {
    return this.getAllConfigs().filter((config) => config.localConfigSupport === "none");
  }
  createBuilder(clientId) {
    const config = this.getConfig(clientId);
    if (!config) {
      throw new Error(`Unknown client: ${clientId}`);
    }
    if (config.localConfigSupport === "none") {
      throw new Error(
        `Cannot create builder for ${config.displayName}: ${config.localConfigNotes || "No local configuration support."}`
      );
    }
    return new ConfigBuilder(config);
  }
};
export {
  BuildOptionsSchema,
  CLIENT,
  CLIENT_DISPLAY_NAME,
  ClientConnectionSupportSchema,
  ClientIdSchema,
  ConfigBuilder,
  ConfigStructureSchema,
  GleanServerConfigSchema,
  GooseConfigSchema,
  GooseServerConfigSchema,
  HttpConfigStructureSchema,
  HttpServerConfigSchema,
  LocalConfigSupportSchema,
  MCPClientConfigSchema,
  MCPConfigRegistry,
  McpServersConfigSchema,
  PlatformPathsSchema,
  PlatformSchema,
  ServerConfigSchema,
  ServerModeSchema,
  ServerTypeSchema,
  StdioConfigStructureSchema,
  StdioServerConfigAltSchema,
  StdioServerConfigSchema,
  VsCodeConfigSchema,
  buildMcpServerName,
  extractServerNameFromUrl,
  getDisplayName,
  normalizeServerName,
  safeValidateClientConfig,
  safeValidateGooseConfig,
  safeValidateMcpServersConfig,
  safeValidateServerConfig,
  safeValidateVsCodeConfig,
  validateClientConfig,
  validateGeneratedConfig,
  validateGooseConfig,
  validateMcpServersConfig,
  validateServerConfig,
  validateVsCodeConfig
};
//# sourceMappingURL=index.js.map